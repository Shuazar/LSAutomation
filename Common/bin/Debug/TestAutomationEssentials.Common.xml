<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TestAutomationEssentials.Common</name>
    </assembly>
    <members>
        <member name="T:TestAutomationEssentials.Common.Configuration.ConfigurationBase">
            <summary>
            Provides a base class for reading values out of an Xml configuration file
            </summary>
            <remarks>
            Good test projects should be able to run on different environments. For example, with desktop application the path
            to the application may be different in every developer's machine and the test servers. In web applications or services,
            the URL of the application or server may be different between different environments. In order to allow that, there's a need
            to read some values from a configuration file.
            <para>
            Note: it's a good practice to keep these files short and simple, and keep it for its mere purpose of supporting different
            environments. Usualy it should contain only 1-3 parameters, like URL or path, and maybe username/password. Everything that
            you can deduce or create automatically is better in order to have a simple user and developer experience.
            </para><para>
            The XML file supported by this class should have one level of elements under the root, each denotes a single property value.
            </para><para>
            Here's a "recipe" for using this class in a way which is robust and user-friendly:
            1. Define an XSD file that describes the supported properties. You can add &lt;annotation/&gt;s to provide additional 
            documentation each property. Note that this XSD file will be used by Visual Studio to provide IntelliSense support when
            editing the XML file
            2. Create one or more XML file using the previously created XSD. You should store at least one file in Source Control
            that describes the environment which is used to run the tests in the CI or nightly build. If you have several predefined 
            environments that you want to run your tests on, you should create one XML file for each of them. Also create one for your own
            dev environment.
            3. Create one .testsettings file for each XML file. Add the XML file to the "Deployment Items" section of the .testsettings file.
            4. Add a class to your project and make it derive from <see cref="T:TestAutomationEssentials.Common.Configuration.ConfigurationBase"/>
            5. Add automatic properties (e.g. <code>public string AppURL { get; set; }</code> for each of parameters in the XML, and 
            decorate them with the <see cref="T:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute"/> attribute, optionally specifying a default value. In case
            that the default value cannot be specified as a constant, instead of the attribute, call <see cref="M:TestAutomationEssentials.Common.Configuration.ConfigurationBase.GetValue(System.Type,System.String,System.Object)"/>
            and specify the value at run-time.
            6. Inside the relevant initialization method (e.g. <see cref="!:TestBase.ClassInitialize()"/>), call <see cref="M:TestAutomationEssentials.Common.Configuration.TestConfig.Load``1(System.String)"/>
            specifying the name of the class you've created. Optionally you can store a reference to the returned object in a member 
            static variable, as the configuration should not change during the entire test run.
            </para><para>
            <h2>Running from Visual Studio</h2>
            When you want to run your tests locally from within Visual Studio, you must use a .testsettings file such as those you created
            in step 3. The file you should use must refer to the XML file that has the correct values for your local environment (or of the
            environment that you want to use when running from Visual Studio). You can select the .testsettings file from the menu bar:
            Test -> Test Settings -> Select Test Settings File.
            Tip: If every developer in the team needs a different configuration, each one should create or edit the local configuration 
            file for to match his environment. If you're using TFS, in order to prevent someone from checking-in his file, you (as the 
            owner of the automation infrastructure) can create a new workspace on your machine with only the folder that contains the XML 
            file, and check it out with Lock type = "Check In - Allow other users to check out but prevent them from checking in".
            <h2>Running from command line</h2>
            If you run the tests using MSTest.exe, you should specify: /testsettings:{your.testsettings}
            If you run the tests using VSTest.Console.exe, you should specify: /runsettings:{your.testsettings}
            </para>
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Configuration.ConfigurationBase.GetValue(System.String)">
            <summary>
            Returns a value with the specified element name from the configuration file
            </summary>
            <param name="elementName">The name of the element</param>
            <returns>The value (inner text) of the element as a string, or <b>null</b> if this element is missing</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.Configuration.ConfigurationBase.GetValue``1(System.String,``0)">
            <summary>
            Returns a value with the specified element name from the configuration file
            </summary>
            <typeparam name="T">The type of the value</typeparam>
            <param name="elementName">The name of the element</param>
            <param name="defaultvalue">The value (inner text) of the element, or <paramref name="defaultvalue"/> if the element is missing</param>
            <returns></returns>
        </member>
        <member name="P:TestAutomationEssentials.Common.Configuration.ConfigurationBase.XmlNamespace">
            <summary>
            When overriden in a derived class, returns the XmlNamespace that is used in the XML configuration file.
            </summary>
        </member>
        <member name="T:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute">
            <summary>
            Marks a property as a configuration parameter
            </summary>
            <remarks>
            Properties marked with that attribute on classes that derive from <see cref="T:TestAutomationEssentials.Common.Configuration.ConfigurationBase"/> are automatically
            set according to their corresponding values in the configuration file upon the call to <see cref="M:TestAutomationEssentials.Common.Configuration.TestConfig.Load``1(System.String)"/>.
            The property can have a private setter.
            <para>
            You can specify a default value that will be used if the elemenet does not exist in the configuration file.
            </para>
            </remarks>
        </member>
        <member name="P:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute.DefaultValue">
            <summary>
            Gets or sets the default value of the property that will be used in case the element does not exist in the configuration file
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute.#ctor">
            <summary>
            Initialized as a new instance with <b>null</b> as the default value
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute.#ctor(System.Object)">
            <summary>
            Initiailized a new instance with the specified default value
            </summary>
            <param name="defaultValue"><see cref="P:TestAutomationEssentials.Common.Configuration.ConfigurationBase.ConfigurationParameterAttribute.DefaultValue"/></param>
        </member>
        <member name="T:TestAutomationEssentials.Common.Configuration.TestConfig">
            <summary>
            Provides utilities for using Test Configuration files
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Configuration.TestConfig.Load``1(System.String)">
            <summary>
            Loads and reads the configuration from the specified file
            </summary>
            <param name="filename">The path of the file to load</param>
            <typeparam name="TConfiguration">The class that exposes the values from the configuration file</typeparam>
            <returns>A new object of type <typeparamref name="TConfiguration"/> that represents the values that were read from the configuration file</returns>
        </member>
        <member name="T:TestAutomationEssentials.Common.DateTimeExtensions">
            <summary>
            Provides extension methods to DateTime, TimeSpan and other methods related to these types
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.Absolute(System.TimeSpan)">
            <summary>
            Returns the absolute timespan that corresponds to the given one
            </summary>
            <param name="timeSpan">The original timespan</param>
            <returns>If the given time span is positive, the method returns the same value; otherwise it returns the opposite (i.e. positive) time span that has the same absolute value as the given one</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.MinutesAsMilliseconds(System.Int32)">
            <summary>
            Calculates the number of milliseconds in the specified number of minutes
            </summary>
            <param name="minutes">The number of minutes to convert to milliseconds</param>
            <returns>The result of the calculation</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.SecondsAsMilliseconds(System.Int32)">
            <summary>
            Calculates the number of milliseconds in the specified number of seconds
            </summary>
            <param name="seconds">The number of seconds to convert to milliseconds</param>
            <returns>The result of the calculation</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.Milliseconds(System.Int32)">
            <summary>
            Returns a <b>TimeSpan</b> that represents the given number of milliseconds
            </summary>
            <param name="milliseconds">The number of milliseconds</param>
            <returns>The <b>TimeSpan</b> struct that represent the given number of milliseconds</returns>
            <example>
            TimeSpan timeSpan = 3.Millisconds();
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.Seconds(System.Int32)">
            <summary>
            Returns a <b>TimeSpan</b> that represents the given number of seconds
            </summary>
            <param name="seconds">The number of seconds</param>
            <returns>The <b>TimeSpan</b> struct that represent the given number of seconds</returns>
            <example>
            TimeSpan timeSpan = 3.Seconds();
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.Minutes(System.Int32)">
            <summary>
            Returns a <b>TimeSpan</b> that represents the given number of minutes
            </summary>
            <param name="minutes">The number of minutes</param>
            <returns>The <b>TimeSpan</b> struct that represent the given number of minutes</returns>
            <example>
            TimeSpan timeSpan = 3.Minutes();
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.Hours(System.Int32)">
            <summary>
            Returns a <b>TimeSpan</b> that represents the given number of hours
            </summary>
            <param name="hours">The number of hours</param>
            <returns>The <b>TimeSpan</b> struct that represent the given number of hours</returns>
            <example>
            TimeSpan timeSpan = 3.Hours();
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.MutliplyBy(System.TimeSpan,System.Double)">
            <summary>
            Multiplies the specified TimeSpan by the specified multiplier
            </summary>
            <param name="multiplicand">The <b>TimeSpan</b> struct to multiply</param>
            <param name="multiplier">The multiplier</param>
            <returns>A <b>TimeSpan</b> representing the calculated multiplication</returns>
            <example>
            Assert.AreEquals(6.Minutes(), 2.Minutes().MultiplyBy(3));
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.ToSpokenString(System.TimeSpan)">
            <summary>
            Returns a string that represent the most significant portions of the specified <b>TimeSpan</b>
            </summary>
            <param name="timeSpan">The <b>TimeSpan</b> to convert to string</param>
            <returns>The string that contains the significant portions of the TimeSpan</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.DateTimeExtensions.TrimMilliseconds(System.DateTime)">
            <summary>
            Rounds toward zero the given date/time's ticks to the nearest millisecond.
            </summary>
            <param name="dateTime">The date/time value to round</param>
            <returns>The rounded date/time</returns>
        </member>
        <member name="T:TestAutomationEssentials.Common.ExecutionContext.IIsolationScope">
            <summary>
            Represents a scope of isolation for tests. Delegates to cleanup actions can be added to the scope at runtime, and they should be called 
            in reverse order when the scope ends.
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.IIsolationScope.AddCleanupAction(System.Action)">
            <summary>
            Adds a delegate to an action to be called on cleanup
            </summary>
            <param name="cleanupAction">The delegate to the action to perform</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="cleanupAction"/> is null</exception>
        </member>
        <member name="T:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager">
            <summary>
            Managed nestable scopes of isolation. Upon exit from each scope, it calls the cleanup actions that were registered to it during its lifetime
            </summary>
            <remarks>
            If you're using MSTest, you should probably use <see cref="!:TestBase"/> instead of using this class directly.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager.#ctor(System.String,System.Action{TestAutomationEssentials.Common.ExecutionContext.IIsolationScope})">
            <summary>
            Initializes a new TestExecutionScopesManager object, with one (default) isolation scope
            </summary>
            <param name="name">The name of the isolation scope</param>
            <param name="initialize">A delegate to an action that is performed on initialization. If an exception occurs inside this 
            method, then the scope is automatically destroyed, calling any cleanup actions that were added during this method</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager.AddCleanupAction(System.Action)">
            <summary>
            Adds a delegate to an action that will be executed on cleanup
            </summary>
            <param name="action">A delegate to the action to perform</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager.BeginIsolationScope(System.String,System.Action{TestAutomationEssentials.Common.ExecutionContext.IIsolationScope})">
            <summary>
            Begins a new, nested, isolation scope
            </summary>
            <param name="isolationScopeName">The name of the new isolation scope</param>
            <param name="initialize">A delegate to an action that is performed on initialization. If an exception occurs inside this 
            method, then the scope is automatically destroyed, calling any cleanup actions that were added during this method</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager.BeginIsolationScope(System.String)">
            <summary>
            Begins a new, nested, isolation scope
            </summary>
            <param name="isolationScopeName">The name of the new isolation scope</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExecutionContext.TestExecutionScopesManager.EndIsolationScope">
            <summary>
            Ends the current isolation scope, calling all cleanup actions that were added to this scope in reverse order
            </summary>
        </member>
        <member name="T:TestAutomationEssentials.Common.ExtensionMethods">
            <summary>
            Provides various general-purpose useful extension methods
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.TryGet``2(``0,System.Func{``0,``1})">
            <summary>
            Returns the result of func(obj) if obj is not null, or null otherwise. Similiar to the <a href="https://msdn.microsoft.com/en-us/library/ty67wk28.aspx">Elvis Operator</a>
            available in C# 6.
            </summary>
            <typeparam name="T1">The type of object</typeparam>
            <typeparam name="T2">The type of the result of func</typeparam>
            <param name="obj">The object to invoke the function on. Can be null</param>
            <param name="func">The function to invoke on <paramref name="obj"/> in case it's not null</param>
            <returns>The result of func(obj) if obj is ot null, or null otherwise</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="func"/> is null</exception>
            <remarks>
            This method is extremely useful when it is used when it is used few times in a row, to get a specific value from a complex data structure that any of its part may be null.
            One common such scenario is when using objects that are generated through XSD.exe or a similiar tool.
            </remarks>
            <example>
            var order = GetOrder(); // may return null
            var street = order.(x => x.Customer).TryGet(x => x.Address).TryGet(x => x.Address);
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.SafeEquals``1(``0,``0)">
            <summary>
            Compares 2 objects, even if they're null.
            </summary>
            <typeparam name="T">The type of object</typeparam>
            <param name="obj1">First object to compare</param>
            <param name="obj2">2nd object to compare</param>
            <returns><b>true</b> if the values of <paramref name="obj1"/> and <paramref name="obj2"/> are the same, even if it's <b>null</b>. Otherwise <b>false</b></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified sequence is empty
            </summary>
            <typeparam name="T">The type of the elements in the sequence</typeparam>
            <param name="source">The sequence</param>
            <returns><b>true</b> if the sequence is empty, otherwise <b>false</b></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Copies a portion of the array into a new array, given the start index and length
            </summary>
            <typeparam name="T">The type of the elements in the array</typeparam>
            <param name="arr">The original array</param>
            <param name="startIndex">The index of the first element to copy</param>
            <param name="length">The number of elements to copy</param>
            <returns>A new array containing only the specified elements</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.SubArray``1(``0[],System.Int32)">
            <summary>
            Copies a portion of the array into a new array, starting at the specified index up to the end of the array
            </summary>
            <typeparam name="T">The type of the elements in the array</typeparam>
            <param name="arr">The original array</param>
            <param name="startIndex">The index of the first element to copy</param>
            <returns>A new array containing the last portion, starting at the specified index</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.GetCurrentMainWindowTitle(System.Diagnostics.Process)">
            <summary>
            Returns the title of the main window of the specified process as it is now
            </summary>
            <param name="process">The process to look for its main window title</param>
            <returns>The title of the main window</returns>
            <remarks>
            Unlike <see cref="P:System.Diagnostics.Process.MainWindowTitle"/>, this method always return the up-to-date title of the main window, even if it has changed after the <see cref="T:System.Diagnostics.Process"/> has been started
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.Content``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the single element contained in the specified sequence
            </summary>
            <typeparam name="T">The type of the element inside the sequence</typeparam>
            <param name="source">The sequence containing the single element</param>
            <returns>The element contained in the sequence</returns>
            <exception cref="T:System.ArgumentNullException">source is null</exception>
            <exception cref="T:System.InvalidOperationException">The sequence is empty or it contains more than one element</exception>
            <remarks>
            This method is similiar to <see cref="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})"/>
            but provide more detailed message if it fails.
            <br/>
            Because it's not possible to "override" a static method, and in order to prevent the inadvertent use of the original 
            <see cref="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})"/> method, this class hides the original
            method by declaring another method with the same name, and an [Obsolete] attribute.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.Find``2(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},``1)">
            <summary>
            Returns the single element in the specified sequence whose specified property has the specified value
            </summary>
            <typeparam name="T1">The type of the elements in the sequence</typeparam>
            <typeparam name="T2">The type of the property</typeparam>
            <param name="source">The sequence containing the element to look for</param>
            <param name="propertyAccessor">A lambda expression that returns the property to compare with <paramref name="expectedValue"/></param>
            <param name="expectedValue">The value of the property that the element should have</param>
            <returns>The element that its property matches the expected value</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null or <paramref name="propertyAccessor"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">The sequence contains no matching element or it contains more than one matching element</exception>
            <remarks>
            This method is similiar to <see cref="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
            but provide more detailed message if it fails.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.Find``1(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Returns the single element in the specified sequence that matches the specified criteria
            </summary>
            <typeparam name="T">The type of the element in the sequence</typeparam>
            <param name="source">The sequence containing the element to look for</param>
            <param name="condition">A lambda expression of a condition that the matching element should pass</param>
            <returns>The element that matches the specified condition</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null or <paramref name="condition"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">The sequence contains no matching element or it contains more than one matching element</exception>
            <remarks>
            This method is similiar to <see cref="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
            but provide more detailed message if it fails.
            <br/>
            Because it's not possible to "override" a static method, and in order to prevent the inadvertent use of the original 
            <see cref="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> method, this class hides the original
            method by declaring another method with the same name, and an [Obsolete] attribute.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.AppendFormatLine(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            Appends a a formatted line to a StringBuilder
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/> to which to append the formatted line</param>
            <param name="format">The format string</param>
            <param name="args">Any arguments to embedded in the format string</param>
            <remarks>
            This method is a simple combination of <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)"/> and <see cref="M:System.Text.StringBuilder.AppendLine"/>
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Appends one dictionary to another
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionaries</typeparam>
            <typeparam name="TValue">The type of the values in the dictionaries</typeparam>
            <param name="originalDictionary">The original dictionary to add the elements to</param>
            <param name="additionalElements">The dictionary that contain the additional elements to add to the original dictionary</param>
            <exception cref="T:System.ArgumentNullException">Either <paramref name="originalDictionary"/> or <paramref name="additionalElements"/> is null</exception>
            <exception cref="T:System.ArgumentException">One or more keys exist for in originalDictionary and additionalElements</exception>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.GetDescription``1(``0)">
            <summary>
            Returns the description of an enum member, according to its DescriptionAttribute if present
            </summary>
            <param name="value">The value of the enum</param>
            <typeparam name="TEnum">The typeof the enum</typeparam>
            <returns>The description of the enum member according to the DescriptionAttribute if present, or the member's name</returns>
            <exception cref="T:System.InvalidOperationException">TEnum is not an enum type</exception>
            <example>
            enum Countries
            {
                [Description("United States")]   
                US,
                [Description("United Kingdom")]
                UK,
                Israel
            }
            
            Console.WriteLine(Countries.US.GetDescription()); // United States
            Console.WriteLine(Countries.UK.GetDescription()); // United Kingdom
            COnsole.WriteLine(Countries.Israel.GetDescription()); // Israel
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.ParseAs``1(System.String)">
            <summary>
            Returns the enum value whose name or description corresponds to the specified string
            </summary>
            <param name="value">The string to parse</param>
            <typeparam name="TEnum">The type of the enum</typeparam>
            <returns>The enum's value whose name or description corresponds to the specified string</returns>
            <exception cref="T:System.ArgumentException"><typeparamref name="TEnum"/> is not an enum type</exception>
            <exception cref="T:System.FormatException">The specified string does not match any of the names or descriptions of the enum members</exception>
            <remarks>
            If members of the enum has a <see cref="T:System.ComponentModel.DescriptionAttribute"/> applied to them, then the specified value can match either
            the name of the member or the value of the <see cref="T:System.ComponentModel.DescriptionAttribute"/>.
            </remarks>
            <example>
            enum Countries
            {
                [Description("United States")]   
                US,
                [Description("United Kingdom")]
                UK,
                Israel
            }
            
            Countries countries;
            countries = "United State".ParseAs&lt;Countries&gt;(); // countries == Countries.US
            countries = "United Kingdom".ParseAs&lt;Countries&gt;(); // countries == Countries.UK
            countries = "UK".ParseAs&lt;Countries&gt;(); // countries == Countries.UK
            countries = "Israel".ParseAs&lt;Countries&gt;(); // countries == Countries.Israel (note that there's no Description attribute on Israel)
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.ExtensionMethods.Truncate(System.String,System.Int32)">
            <summary>
            Truncates the given string to the specified length
            </summary>
            <param name="text">The original string</param>
            <param name="maxLength">The maximum length to keep</param>
            <returns>If <paramref name="maxLength"/> is greater than the length of <paramref name="text"/> this method returns <paramref name="text"/>,
            otherwise, it returns the first <paramref name="maxLength"/> characters of <paramref name="text"/></returns>
        </member>
        <member name="T:TestAutomationEssentials.Common.Functions">
            <summary>
            Provides general purpose methods that are useful for working in a functional manner in C#
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Functions.Negate(System.Func{System.Boolean})">
            <summary>
            Returns a new function that negates the result of another boolean function
            </summary>
            <param name="func">The original boolean function</param>
            <returns>A new method that returns the opposite result of <paramref name="func"/></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.Functions.EmptyAction">
            <summary>
            Returns a delegate to an <see cref="T:System.Action"/> that does nothing
            </summary>
            <returns>A delegate to an <see cref="T:System.Action"/> that does nothing</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.Functions.EmptyAction``1">
            <summary>
            Returns a delegate to an <see cref="T:System.Action`1"/> that does nothing
            </summary>
            <returns>A delegate to an <see cref="T:System.Action`1"/> that does nothing</returns>
        </member>
        <member name="T:TestAutomationEssentials.Common.ImageExtensions">
            <summary>
            Provides useful methods to work with Images
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.ImageExtensions.ToImage(System.Byte[])">
            <summary>
            Creates an image from a byte array
            </summary>
            <param name="bytes">A byte array that comprise the image, in every format that may be stored in a valid image file</param>
            <returns>The corresponding image</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ImageExtensions.FitToSize(System.Drawing.Image,System.Drawing.Size)">
            <summary>
            Resizes the given image to fit in the specified size
            </summary>
            <param name="image">The image to resize</param>
            <param name="targetSize">The target size of the image</param>
            <returns>A new <see cref="T:System.Drawing.Bitmap"/> object that contains the resized image</returns>
            <remarks>
            The method can either shrink or grow the original image, but always keeps the original ratio. If the ratio of the original
            image is not the same as of the target size, then the image is centered and the borders (either top &amp; bottom or left &amp; right)
            are left empty (black)
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ImageExtensions.GetBitmapBytes(System.Drawing.Image)">
            <summary>
            Returns the bytes of a bitmap as they would be saved to a .bmp file
            </summary>
            <param name="image">The image to serialize</param>
            <returns>A byte array containing the serialized image as a bitmap</returns>
        </member>
        <member name="T:TestAutomationEssentials.Common.Logger">
            <summary>
            Writes log entries, using indentations to enhance its readability
            </summary>
        </member>
        <member name="T:TestAutomationEssentials.Common.Logger.DefaultImplementations">
            <summary>
            Provides default implementations for WriteLine that can be used with <see cref="M:TestAutomationEssentials.Common.Logger.Initialize(System.Action{System.String})"/>
            </summary>
        </member>
        <member name="F:TestAutomationEssentials.Common.Logger.DefaultImplementations.Console">
            <summary>
            Provides the implementation that writes the line to the Console's output
            </summary>
        </member>
        <member name="F:TestAutomationEssentials.Common.Logger.DefaultImplementations.Trace">
            <summary>
            Provides the implementation that writes the line to the debugger's trace output
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.Initialize(System.Action{System.String})">
            <summary>
            Initializes the logger to use the specified implementation for writing a line to the log
            </summary>
            <param name="writeLineImpl">A delegate that writes a line to the log. You can use any of the members of 
            <seealso cref="T:TestAutomationEssentials.Common.Logger.DefaultImplementations"/> or provide your own
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="writeLineImpl"/> is null</exception>
            <remarks>
            You should only call this method once in your assembly initialization code (i.e. [AssemblyInitialize] method if you're using MSTest)
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.Initialize(TestAutomationEssentials.Common.ICustomLogger)">
            <summary>
            Initializes the logger to use a custom logger that performs the writes to the log
            </summary>
            <param name="customLogger">An object that implements <see cref="T:TestAutomationEssentials.Common.ICustomLogger"/>. Provide your own implementation for this interface to
            handle where and how the log entries are written
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="customLogger"/> is null</exception>
            <remarks>
            You should only call this method once in your assembly initialization code (i.e. [AssemblyInitialize] method if you're using MSTest)
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.WriteLine(System.String,System.Object[])">
            <summary>
            Writes a line to the log, in the current indentation level, and the current time
            </summary>
            <param name="format">The format of the line</param>
            <param name="args">The format arguments to embbed in the line</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.WriteLine(System.Object)">
            <summary>
            Writes the string representation (.ToString()) of the object to the log
            </summary>
            <param name="obj">The object whose string representation should be written to the log</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.IncreaseIndent">
            <summary>
            Increases the indentation for the upcoming writes
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.DecreaseIndent">
            <summary>
            Decreases the indentation for the upcoming writes
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Logger.StartSection(System.String,System.Object[])">
            <summary>
            Writes the specified formatted line to the log, and increases the indentation for the upcoming writes, until the returned object is disposed
            </summary>
            <param name="format">The format of the line</param>
            <param name="args">The format arguments to embbed in the line</param>
            <returns>An IDisposable object, which when disposed returns the indentation back to what it was before <seealso cref="M:TestAutomationEssentials.Common.Logger.StartSection(System.String,System.Object[])"/> was called</returns>
            <remarks>
            This method is mainly useful inside a <b>using</b> statement, as in the following example:
            </remarks>
            <example>
            <code>
            Logger.WriteLine("This is an ordinary line");
            using(Logger.StartSection("This is the section header"))
            {
            	Logger.WriteLine("This is an indented line");
            	using(Logger.StartSection("This is a section header for a deeper section"))
            	{
            		Logger.Writeline("This line is indented even deeper");
            	}
            	Logger.WriteLine("This is still part of the outer section");
            }
            Logger.WriteLine("This is an ordinary line after the section has completed");
            </code>
            <para>The result is:</para>
            <code>
            This is an ordinary line
            This is the section header
            	This is an indented line
            	This is a section header for a deeper section
            			This line is indented even deeper
            	This is still part of the outer section
            This is an ordinary line after the section has completed
            </code>
            </example>
        </member>
        <member name="T:TestAutomationEssentials.Common.ICustomLogger">
            <summary>
            Defines methods to be implemented by customer loggers
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.ICustomLogger.WriteLine(System.DateTime,System.String)">
            <summary>
            Writes a single message to the log
            </summary>
            <param name="timestamp">The date and time when the message was written</param>
            <param name="message">The text of the message</param>
        </member>
        <member name="M:TestAutomationEssentials.Common.ICustomLogger.StartSection(System.DateTime,System.String)">
            <summary>
            Writes a message that begins a new section. All subsequent message are related to this
            new section, until <see cref="M:TestAutomationEssentials.Common.ICustomLogger.EndSection(System.DateTime)"/> is called
            </summary>
            <param name="timestamp">The date and time when the message was written</param>
            <param name="message">The text of the message for the section header</param>
            <remarks>
            This method can be called multiple times before <see cref="M:TestAutomationEssentials.Common.ICustomLogger.EndSection(System.DateTime)"/> is called.
            This should create a nested sections. Each section should be closed with the matching
            <see cref="M:TestAutomationEssentials.Common.ICustomLogger.EndSection(System.DateTime)"/>.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.ICustomLogger.EndSection(System.DateTime)">
            <summary>
            Ends the most recently active section.
            </summary>
            <param name="timestamp">The date and time when the section was ended</param>
        </member>
        <member name="T:TestAutomationEssentials.Common.PathUtils">
            <summary>
            Provide useful methods to work with file-system paths, beyond those in <see cref="T:System.IO.Path"/>
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.PathUtils.IsInFolder(System.String,System.String)">
            <summary>
            Determines whether the a file or folder is contained in another folder
            </summary>
            <param name="path">The path of the file or folder. This can be either a relative or full path</param>
            <param name="containingFolder">The path of the folder to check if it contains <paramref name="path"/>. This can be eitehr a relative or full path</param>
            <returns><b>true</b> if <paramref name="path"/> is inside <paramref name="containingFolder"/>, otherwise <b>false</b></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.PathUtils.GetDesktopFolder">
            <summary>
            Returns the absolute path of the desktop folder
            </summary>
            <returns>The absolute path of the desktop folder</returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.PathUtils.GetAncestorPath(System.String,System.String)">
            <summary>
            Returns the full path of the an ancestor folder of another path
            </summary>
            <param name="containingPath">A path to a file or folder inside <paramref name="ancestorFolderName"/>. If this path is relative, it is assumed to be relative to the current directory</param>
            <param name="ancestorFolderName">The name of a folder that should be up the hierarchy of <paramref name="containingPath"/>. It's also possible to specify multiple nested folders that should be together in the hierarchy of <paramref name="containingPath"/></param>
            <returns>The full path of <paramref name="ancestorFolderName"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="containingPath"/> or <paramref name="ancestorFolderName"/> is <b>null</b></exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="ancestorFolderName"/> cannot be found up the hierarchy of <paramref name="containingPath"/></exception>
            <example>
            var ancestor = PathUtils.GetAncestorPath(@"C:\folder1\folder2\folder3\folder4", "folder2");
            // ancestor == @"c:\folder1\folder2
            </example>
            <example>
            var ancestor = PathUtils.GetAncestorPath(@"C:\folder1\folder2\folder3\folder4\folder3", "@"folder2\folder3"");
            // ancestor == @"C:\folder1\folder2\folder3
            </example>
        </member>
        <member name="T:TestAutomationEssentials.Common.ReflectionExtensions">
            <summary>
            Provides useful extension methods for working with Reflection, beyond those in <see cref="T:System.Reflection.CustomAttributeExtensions"/>
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.ReflectionExtensions.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Determines whether the specified member has the specified attribute
            </summary>
            <typeparam name="TAttribute">The type of the attribute to search for</typeparam>
            <param name="member">The member to inspect</param>
            <returns><b>true</b> if the member has the specified attribute, otherwise <b>false</b></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ReflectionExtensions.DerivesFrom(System.Type,System.Type)">
            <summary>
            Determines whether the given type is a subclass of another type
            </summary>
            <param name="t1">The type to inspect</param>
            <param name="t2">The type to check for being a base class of <paramref name="t1"/></param>
            <returns><b>true</b> if <paramref name="t1"/> derives from <paramref name="t2"/>, otherwise <b>false</b></returns>
        </member>
        <member name="M:TestAutomationEssentials.Common.ReflectionExtensions.GetDefaultValue(System.Type)">
            <summary>
            Returns the default value of the specified type
            </summary>
            <param name="t">The type to get its default value</param>
            <returns>The default value of the specified type</returns>
            <remarks>
            This method is similiar to the expression: <code>default(T)</code> that is useful mainly in Generic methods.
            However, with <code>default(T)</code> the type must be known at compile time (or be a generic type), while with this '
            method, the type can be specified at run-time.
            </remarks>
        </member>
        <member name="T:TestAutomationEssentials.Common.Wait">
            <summary>
            Provide convinient methods for waiting for a condition to come true.
            </summary>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.Until(System.Linq.Expressions.Expression{System.Func{System.Boolean}},System.TimeSpan)">
            <summary>
            Waits until the specified condition becomes true
            </summary>
            <param name="conditionExpr">A lamba expression containing the condition</param>
            <param name="timeout">The maximum time to wait for the condition</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conditionExpr"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become true for the specified timeout</exception>
            <example>
            Wait.Until(() => PageIsLoaded(), 30.Seconds());
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.While(System.Linq.Expressions.Expression{System.Func{System.Boolean}},System.TimeSpan)">
            <summary>
            Waits until the specified condition becomes false
            </summary>
            <param name="conditionExpr">A lambda expression containing the condition</param>
            <param name="timeout">The maximum time to wait for the condition to become false</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="conditionExpr"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become false for the specified timeout</exception>
            <example>
            Wait.While(() => PleaseWaitMessageAppears(), 30.Seconds());
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.While(System.Func{System.Boolean},System.TimeSpan,System.String,System.Object[])">
            <summary>
            Waits until the specified condition becomes false
            </summary>
            <param name="condition">The condition to wait for to become false</param>
            <param name="timeout">The maximum time to wait for the condition to become false</param>
            <param name="timeoutMessage">The message to use in the exception in case of a timeout</param>
            <param name="args">Additional format arguments to embedd in <paramref name="timeoutMessage"/></param>
            <exception cref="T:System.ArgumentNullException">Any of the arguments is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.FormatException">timeoutMessage is invalid.-or- The index of a format item is less than zero, or greater
                than or equal to the length of the args array.</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become false for the specified timeout. The message of the 
            exception is specified by the <paramref name="timeoutMessage"/> argument</exception>
            <example>
            Wait.While(() => PopupIsDisplayed(), 30.Seconds(), "Popup didn't disappear!");
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.Until(System.Func{System.Boolean},System.TimeSpan,System.String,System.Object[])">
            <summary>
            Waits until the specified condition becomes true. In case of a timeout, the specified message is used in the exception
            </summary>
            <param name="condition">The condition to wait for to become true</param>
            <param name="timeout">The maximum time to wait for the condition to become true</param>
            <param name="timeoutMessage">The message to use in the exception in case of a timeout</param>
            <param name="args">Additional format arguments to embedd in <paramref name="timeoutMessage"/></param>
            <exception cref="T:System.ArgumentNullException">Any of the arguments is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.FormatException">timeoutMessage is invalid.-or- The index of a format item is less than zero, or greater
                than or equal to the length of the args array.</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become true for the specified timeout. The message of the 
            exception is specified by the <paramref name="timeoutMessage"/> argument</exception>
            <example>
            Wait.Until(() => PageIsLoaded(), 30.Seconds(), "Page wasn't loaded!");
            </example>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.Until``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.TimeSpan)">
            <summary>
            Evaluates the specified expression until it meets the specified condition, and return the value of this expression
            </summary>
            <param name="getResultExpr">The expression to evaulate</param>
            <param name="conditionExpr">The condition to wait for to become true</param>
            <param name="timeout">The maximum time to wait for the condition to become true</param>
            <typeparam name="T">The type that the expression resolves to</typeparam>
            <returns>The value of the expression when it meets the condition</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="getResultExpr"/> or <paramref name="conditionExpr"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become true for the specified timeout</exception>
            <example>
            // Waits until the quote reaches 10 and returns it
            Quote quote = Wait.Until(() => GetQuote(), qt => qt.Value > 10, 5.Minutes());
            Console.WriteLine(quote.Name);
            </example>
            <remarks>
            When this method throws <see cref="T:System.TimeoutException"/>, it uses the expressions as part of the exception's message
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.Until``1(System.Func{``0},System.Func{``0,System.Boolean},System.TimeSpan,System.String,System.Object[])">
            <summary>
            Invokes the specified delegate until its return value meets the specified condition, and returns that value
            </summary>
            <param name="getResult">The delegate to invoke</param>
            <param name="condition">The condition to wait for to become true</param>
            <param name="timeout">The maximum time to wait for the condition to become true</param>
            <param name="timeoutMessage">The message to use in the exception in case of a timeout</param>
            <param name="args">Additional format arguments to embedd in <paramref name="timeoutMessage"/></param>
            <typeparam name="T">The type that the delegate returns</typeparam>
            <returns>The return value of the delegate when it meets the condition</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="getResult"/>, <paramref name="condition"/>, <paramref name="timeout"/> or <paramref name="args"/>is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is negative</exception>
            <exception cref="T:System.TimeoutException">The condition didn't become true for the specified timeout</exception>
            <exception cref="T:System.FormatException">timeoutMessage is invalid.-or- The index of a format item is less than zero, or greater
                than or equal to the length of the args array.</exception>
            <example>
            // Waits until the quote reaches 10 and returns it
            Quote quote = Wait.Until(() => GetQuote(), qt => qt.Value > 10, 5.Minutes(), "Quote didn't reach {0}", 10);
            </example>
            <remarks>
            When this method throws <see cref="T:System.TimeoutException"/> it uses the <paramref name="timeoutMessage"/> and its corresponding 
            <paramref name="args"/> as the message of the exception
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.IfNot(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Waits until the specified condition is met or until the specified period has passed, whichever comes first. This method doesn't throw TimeoutException.
            </summary>
            <param name="condition">The condition to evaluate</param>
            <param name="period">The period to wait for the condition</param>
            <returns>Whether the condition has been met</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> is negative</exception>
            <remarks>
            You should use it for non critical and possibly very short conditions that the polling may miss. After calling this method you should verify (or wait) 
            for a different condition that indicates that the operation has actually completed or not.
            </remarks>
        </member>
        <member name="M:TestAutomationEssentials.Common.Wait.If(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Waits while the specified condition is met or until the specified period has passed. This method doesn't throw TimeoutException.
            </summary>
            <param name="condition">The condition to evaluate</param>
            <param name="period">The period to wait for the condition</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> is negative</exception>
            <returns>Whether the condition has been met</returns>
            <remarks>
            You should use it for non critical and possibly very short conditions that the polling may miss. After calling this method you should verify (or wait) 
            for a different condition that indicates that the operation has actually completed or not.
            </remarks>
        </member>
    </members>
</doc>
